// Copyright 2017 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////////

// Definitions for Cloud Crypto SDK (Tink) library.

// @generated by protoc-gen-es v1.5.0 with parameter "target=ts"
// @generated from file tink.proto (package google.crypto.tink, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";

/**
 * @generated from enum google.crypto.tink.KeyStatusType
 */
export enum KeyStatusType {
  /**
   * @generated from enum value: UNKNOWN_STATUS = 0;
   */
  UNKNOWN_STATUS = 0,

  /**
   * Can be used for crypto operations.
   *
   * @generated from enum value: ENABLED = 1;
   */
  ENABLED = 1,

  /**
   * Cannot be used, but exists and can become ENABLED.
   *
   * @generated from enum value: DISABLED = 2;
   */
  DISABLED = 2,

  /**
   * Key data does not exist in this Keyset any more.
   *
   * @generated from enum value: DESTROYED = 3;
   */
  DESTROYED = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(KeyStatusType)
proto3.util.setEnumType(KeyStatusType, "google.crypto.tink.KeyStatusType", [
  { no: 0, name: "UNKNOWN_STATUS" },
  { no: 1, name: "ENABLED" },
  { no: 2, name: "DISABLED" },
  { no: 3, name: "DESTROYED" },
]);

/**
 * Tink produces and accepts ciphertexts or signatures that consist
 * of a prefix and a payload. The payload and its format is determined
 * entirely by the primitive, but the prefix has to be one of the following
 * 4 types:
 *   - Legacy: prefix is 5 bytes, starts with \x00 and followed by a 4-byte
 *             key id that is computed from the key material. In addition to
 *             that, signature schemes and MACs will add a \x00 byte to the
 *             end of the data being signed / MACed when operating on keys
 *             with this OutputPrefixType.
 *   - Crunchy: prefix is 5 bytes, starts with \x00 and followed by a 4-byte
 *             key id that is generated randomly.
 *   - Tink  : prefix is 5 bytes, starts with \x01 and followed by 4-byte
 *             key id that is generated randomly.
 *   - Raw   : prefix is 0 byte, i.e., empty.
 *
 * @generated from enum google.crypto.tink.OutputPrefixType
 */
export enum OutputPrefixType {
  /**
   * @generated from enum value: UNKNOWN_PREFIX = 0;
   */
  UNKNOWN_PREFIX = 0,

  /**
   * @generated from enum value: TINK = 1;
   */
  TINK = 1,

  /**
   * @generated from enum value: LEGACY = 2;
   */
  LEGACY = 2,

  /**
   * @generated from enum value: RAW = 3;
   */
  RAW = 3,

  /**
   * @generated from enum value: CRUNCHY = 4;
   */
  CRUNCHY = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(OutputPrefixType)
proto3.util.setEnumType(OutputPrefixType, "google.crypto.tink.OutputPrefixType", [
  { no: 0, name: "UNKNOWN_PREFIX" },
  { no: 1, name: "TINK" },
  { no: 2, name: "LEGACY" },
  { no: 3, name: "RAW" },
  { no: 4, name: "CRUNCHY" },
]);

/**
 * @generated from message google.crypto.tink.KeyTemplate
 */
export class KeyTemplate extends Message<KeyTemplate> {
  /**
   * Required. The type_url of the key type in format
   * type.googleapis.com/packagename.messagename -- see above for details.
   * This is typically the protobuf type URL of the *Key proto. In particular,
   * this is different of the protobuf type URL of the *KeyFormat proto.
   *
   * @generated from field: string type_url = 1;
   */
  typeUrl = "";

  /**
   * Required. The serialized *KeyFormat proto.
   *
   * @generated from field: bytes value = 2;
   */
  value = new Uint8Array(0);

  /**
   * Required. The type of prefix used when computing some primitives to
   * identify the ciphertext/signature, etc.
   *
   * @generated from field: google.crypto.tink.OutputPrefixType output_prefix_type = 3;
   */
  outputPrefixType = OutputPrefixType.UNKNOWN_PREFIX;

  constructor(data?: PartialMessage<KeyTemplate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.crypto.tink.KeyTemplate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type_url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "value", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "output_prefix_type", kind: "enum", T: proto3.getEnumType(OutputPrefixType) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): KeyTemplate {
    return new KeyTemplate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): KeyTemplate {
    return new KeyTemplate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): KeyTemplate {
    return new KeyTemplate().fromJsonString(jsonString, options);
  }

  static equals(a: KeyTemplate | PlainMessage<KeyTemplate> | undefined, b: KeyTemplate | PlainMessage<KeyTemplate> | undefined): boolean {
    return proto3.util.equals(KeyTemplate, a, b);
  }
}

/**
 * The actual *Key-proto is wrapped in a KeyData message, which in addition
 * to this serialized proto contains also type_url identifying the
 * definition of *Key-proto (as in KeyFormat-message), and some extra metadata
 * about the type key material.
 *
 * @generated from message google.crypto.tink.KeyData
 */
export class KeyData extends Message<KeyData> {
  /**
   * Required.
   *
   * In format type.googleapis.com/packagename.messagename
   *
   * @generated from field: string type_url = 1;
   */
  typeUrl = "";

  /**
   * Required.
   * Contains specific serialized *Key proto
   *
   * Placeholder for ctype.
   *
   * @generated from field: bytes value = 2;
   */
  value = new Uint8Array(0);

  /**
   * Required.
   *
   * @generated from field: google.crypto.tink.KeyData.KeyMaterialType key_material_type = 3;
   */
  keyMaterialType = KeyData_KeyMaterialType.UNKNOWN_KEYMATERIAL;

  constructor(data?: PartialMessage<KeyData>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.crypto.tink.KeyData";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type_url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "value", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "key_material_type", kind: "enum", T: proto3.getEnumType(KeyData_KeyMaterialType) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): KeyData {
    return new KeyData().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): KeyData {
    return new KeyData().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): KeyData {
    return new KeyData().fromJsonString(jsonString, options);
  }

  static equals(a: KeyData | PlainMessage<KeyData> | undefined, b: KeyData | PlainMessage<KeyData> | undefined): boolean {
    return proto3.util.equals(KeyData, a, b);
  }
}

/**
 * @generated from enum google.crypto.tink.KeyData.KeyMaterialType
 */
export enum KeyData_KeyMaterialType {
  /**
   * @generated from enum value: UNKNOWN_KEYMATERIAL = 0;
   */
  UNKNOWN_KEYMATERIAL = 0,

  /**
   * @generated from enum value: SYMMETRIC = 1;
   */
  SYMMETRIC = 1,

  /**
   * @generated from enum value: ASYMMETRIC_PRIVATE = 2;
   */
  ASYMMETRIC_PRIVATE = 2,

  /**
   * @generated from enum value: ASYMMETRIC_PUBLIC = 3;
   */
  ASYMMETRIC_PUBLIC = 3,

  /**
   * points to a remote key, i.e., in a KMS.
   *
   * @generated from enum value: REMOTE = 4;
   */
  REMOTE = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(KeyData_KeyMaterialType)
proto3.util.setEnumType(KeyData_KeyMaterialType, "google.crypto.tink.KeyData.KeyMaterialType", [
  { no: 0, name: "UNKNOWN_KEYMATERIAL" },
  { no: 1, name: "SYMMETRIC" },
  { no: 2, name: "ASYMMETRIC_PRIVATE" },
  { no: 3, name: "ASYMMETRIC_PUBLIC" },
  { no: 4, name: "REMOTE" },
]);

/**
 * A Tink user works usually not with single keys, but with keysets,
 * to enable key rotation.  The keys in a keyset can belong to different
 * implementations/key types, but must all implement the same primitive.
 * Any given keyset (and any given key) can be used for one primitive only.
 *
 * @generated from message google.crypto.tink.Keyset
 */
export class Keyset extends Message<Keyset> {
  /**
   * Identifies key used to generate new crypto data (encrypt, sign).
   * Required.
   *
   * @generated from field: uint32 primary_key_id = 1;
   */
  primaryKeyId = 0;

  /**
   * Actual keys in the Keyset.
   * Required.
   *
   * @generated from field: repeated google.crypto.tink.Keyset.Key key = 2;
   */
  key: Keyset_Key[] = [];

  constructor(data?: PartialMessage<Keyset>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.crypto.tink.Keyset";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "primary_key_id", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "key", kind: "message", T: Keyset_Key, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Keyset {
    return new Keyset().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Keyset {
    return new Keyset().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Keyset {
    return new Keyset().fromJsonString(jsonString, options);
  }

  static equals(a: Keyset | PlainMessage<Keyset> | undefined, b: Keyset | PlainMessage<Keyset> | undefined): boolean {
    return proto3.util.equals(Keyset, a, b);
  }
}

/**
 * @generated from message google.crypto.tink.Keyset.Key
 */
export class Keyset_Key extends Message<Keyset_Key> {
  /**
   * Contains the actual, instantiation specific key proto.
   * By convention, each key proto contains a version field.
   *
   * @generated from field: google.crypto.tink.KeyData key_data = 1;
   */
  keyData?: KeyData;

  /**
   * @generated from field: google.crypto.tink.KeyStatusType status = 2;
   */
  status = KeyStatusType.UNKNOWN_STATUS;

  /**
   * Identifies a key within a keyset, is a part of metadata
   * of a ciphertext/signature.
   *
   * @generated from field: uint32 key_id = 3;
   */
  keyId = 0;

  /**
   * Determines the prefix of the ciphertexts/signatures produced by this key.
   * This value is copied verbatim from the key template.
   *
   * @generated from field: google.crypto.tink.OutputPrefixType output_prefix_type = 4;
   */
  outputPrefixType = OutputPrefixType.UNKNOWN_PREFIX;

  constructor(data?: PartialMessage<Keyset_Key>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.crypto.tink.Keyset.Key";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "key_data", kind: "message", T: KeyData },
    { no: 2, name: "status", kind: "enum", T: proto3.getEnumType(KeyStatusType) },
    { no: 3, name: "key_id", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 4, name: "output_prefix_type", kind: "enum", T: proto3.getEnumType(OutputPrefixType) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Keyset_Key {
    return new Keyset_Key().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Keyset_Key {
    return new Keyset_Key().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Keyset_Key {
    return new Keyset_Key().fromJsonString(jsonString, options);
  }

  static equals(a: Keyset_Key | PlainMessage<Keyset_Key> | undefined, b: Keyset_Key | PlainMessage<Keyset_Key> | undefined): boolean {
    return proto3.util.equals(Keyset_Key, a, b);
  }
}

/**
 * Represents a "safe" Keyset that doesn't contain any actual key material,
 * thus can be used for logging or monitoring. Most fields are copied from
 * Keyset.
 *
 * @generated from message google.crypto.tink.KeysetInfo
 */
export class KeysetInfo extends Message<KeysetInfo> {
  /**
   * See Keyset.primary_key_id.
   *
   * @generated from field: uint32 primary_key_id = 1;
   */
  primaryKeyId = 0;

  /**
   * KeyInfos in the KeysetInfo.
   * Each KeyInfo is corresponding to a Key in the corresponding Keyset.
   *
   * @generated from field: repeated google.crypto.tink.KeysetInfo.KeyInfo key_info = 2;
   */
  keyInfo: KeysetInfo_KeyInfo[] = [];

  constructor(data?: PartialMessage<KeysetInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.crypto.tink.KeysetInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "primary_key_id", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "key_info", kind: "message", T: KeysetInfo_KeyInfo, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): KeysetInfo {
    return new KeysetInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): KeysetInfo {
    return new KeysetInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): KeysetInfo {
    return new KeysetInfo().fromJsonString(jsonString, options);
  }

  static equals(a: KeysetInfo | PlainMessage<KeysetInfo> | undefined, b: KeysetInfo | PlainMessage<KeysetInfo> | undefined): boolean {
    return proto3.util.equals(KeysetInfo, a, b);
  }
}

/**
 * @generated from message google.crypto.tink.KeysetInfo.KeyInfo
 */
export class KeysetInfo_KeyInfo extends Message<KeysetInfo_KeyInfo> {
  /**
   * the type url of this key,
   * e.g., type.googleapis.com/google.crypto.tink.HmacKey.
   *
   * @generated from field: string type_url = 1;
   */
  typeUrl = "";

  /**
   * See Keyset.Key.status.
   *
   * @generated from field: google.crypto.tink.KeyStatusType status = 2;
   */
  status = KeyStatusType.UNKNOWN_STATUS;

  /**
   * See Keyset.Key.key_id.
   *
   * @generated from field: uint32 key_id = 3;
   */
  keyId = 0;

  /**
   * See Keyset.Key.output_prefix_type.
   *
   * @generated from field: google.crypto.tink.OutputPrefixType output_prefix_type = 4;
   */
  outputPrefixType = OutputPrefixType.UNKNOWN_PREFIX;

  constructor(data?: PartialMessage<KeysetInfo_KeyInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.crypto.tink.KeysetInfo.KeyInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type_url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "status", kind: "enum", T: proto3.getEnumType(KeyStatusType) },
    { no: 3, name: "key_id", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 4, name: "output_prefix_type", kind: "enum", T: proto3.getEnumType(OutputPrefixType) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): KeysetInfo_KeyInfo {
    return new KeysetInfo_KeyInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): KeysetInfo_KeyInfo {
    return new KeysetInfo_KeyInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): KeysetInfo_KeyInfo {
    return new KeysetInfo_KeyInfo().fromJsonString(jsonString, options);
  }

  static equals(a: KeysetInfo_KeyInfo | PlainMessage<KeysetInfo_KeyInfo> | undefined, b: KeysetInfo_KeyInfo | PlainMessage<KeysetInfo_KeyInfo> | undefined): boolean {
    return proto3.util.equals(KeysetInfo_KeyInfo, a, b);
  }
}

/**
 * Represents a keyset that is encrypted with a master key.
 *
 * @generated from message google.crypto.tink.EncryptedKeyset
 */
export class EncryptedKeyset extends Message<EncryptedKeyset> {
  /**
   * Required.
   *
   * @generated from field: bytes encrypted_keyset = 2;
   */
  encryptedKeyset = new Uint8Array(0);

  /**
   * Optional.
   *
   * @generated from field: google.crypto.tink.KeysetInfo keyset_info = 3;
   */
  keysetInfo?: KeysetInfo;

  constructor(data?: PartialMessage<EncryptedKeyset>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.crypto.tink.EncryptedKeyset";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "encrypted_keyset", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "keyset_info", kind: "message", T: KeysetInfo },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EncryptedKeyset {
    return new EncryptedKeyset().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EncryptedKeyset {
    return new EncryptedKeyset().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EncryptedKeyset {
    return new EncryptedKeyset().fromJsonString(jsonString, options);
  }

  static equals(a: EncryptedKeyset | PlainMessage<EncryptedKeyset> | undefined, b: EncryptedKeyset | PlainMessage<EncryptedKeyset> | undefined): boolean {
    return proto3.util.equals(EncryptedKeyset, a, b);
  }
}

